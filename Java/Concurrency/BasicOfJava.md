# ``Java``基础

1. 变量
    ![Fileds](../Image/AllKindOfFileds.png)
    1. 成员变量是在类中定义的变量。而局部变量可以是在方法中定义的变量，也可以是在代码块中定义的变量。此处的代码块可以是方法中的代码块或者类中的静态/非静态代码块。而局部变量根据定义的形式不同，可以分为以下3种：
        + 形参：在方法签名中定义的变量，作用域在整个方法中有效。所以后面不能出现一个和该变量**名称**相同的变量（尽管类型可能不相同），否则会出现多重定义编译错误。
        + 方法局部变量：在方法体内定义的变量，作用域从定义该变量的地方生效，到方法结束时失效
        + 代码块局部变量：在代码块中定义的局部变量，这个局部变量的作用域从定义该变量的地方生效，到代码块结束时失效。代码块可能出现在两个地方：
            + 出现在类中：包括静态代码块和实例初始化块
            + 出现在方法中
        + 通过实例引用去访问类变量，本质上还是委托给该类来访问类变量。因此，即使实例引用为``null``，也能访问它所属的类成员。但是访问实例变量，会抛出``NullPointerException``异常

        + ``Java``允许局部变量和成员变量同名，如果方法里的局部变量与成员变量同名，那么，局部变量会覆盖成员变量（注意：成员变量的作用域是整个类范围内有效，即如果方法中输出一个方法中没定义的变量，那么是肯定没问题的。因为输出的就是这个成员变量）。不会出现重定义错误。

        + 局部变量保存在方法的栈内存中，每个调用该方法的线程均会有一份自己独立的局部变量。互相不会受影响。

            ```java
                int age = 10;
                // double age = 78.3  // 会出现重定义编译错误。即与什么类型，什么修饰符无关。仅仅与变量的名字有关。如果两个名字相同，那么就会出现重定义编译错误
            ```

    2. 成员变量（注意包括实例变量和类变量）不需要进行显示初始化，会自动进行隐式初始化赋**0**值。而局部变量除了形参之外，必须要显示进行初始化后才能使用。否则报错。形参的初始化在调用该方法时由系统完成，形参的值由方法的调用者指定。

    3. 初始化块
        + 初始化块的修饰符如果有的话，那么只能是``static``。使用``static``修饰的初始化块称之为静态初始化块。初始化块里面的代码可以包含任何可执行语句，包括定义局部变量（注意可能会出现重定义编译错误）、调用其他对象的方法，以及使用分支循环等。

        + 非静态初始化块在实例创建的时候会被执行，且非静态初始化块本质上是构造器的一部分，创建实例时会被加入到构造器中，且会与构造器所有代码的最前面。

        + 静态初始化块仅仅在类被加载时执行一次。且也要遵循静态成员不能访问非静态成员的规定。

2. ``final``关键字
    ``final``可以修饰变量，方法和类。用于表示所修饰的内容一旦经过赋值之后便不能被修改。
    + ``final``修饰的成员变量必须必须显示的指定初始值。
        + 对于类变量：必须在静态初始化块中指定初始值（前提没有在申明的时候指定初始值）或者申明该类变量时指定初始值
        **注意可能发生的重定义编译错误，以及前向引用错误**
        + 实例变量：必须在非静态初始化块、申明实例变量或者构造器中指定初始值
        + 对于局部变量：由于系统变量系统不会为其进行初始化，必须要显示初始化，因此``final``修饰的局部变量，可以在定义时指定默认值，也可以不指定默认值。如果在定义时没有进行指定默认值，那么后面代码在对这个变量赋初值的时候，只能进行一次，不能够多次赋值。如果定义时指定了初始值，那么后面便不能在对其赋初值了。

        + ``final``修饰的基本数据类型一旦经过赋值便不能够更改。而对于应用数据类型，它仅仅保存的是一个引用，``final``只保证这个引用类型变量所引用的地址不会发生变化，即一直引用这个对象，但这个对象的内部属性是可以发生变化的。
    + ``final``修饰的方法
        + ``final``修饰的方法不可以被``override``，即子类不能重写父类``final``修饰的方法。注意``override``时的两同，两小，一大的原则。**注意：子类重写方法的返回值类型应为父类方法返回值类型的子类 或和父类方法返回值类型相等**

        + ``final``修饰的方法可以被重载

        + 对于一个``private``修饰的方法，由于它仅仅在当前类的内部可见，其子类是无法继承也无法访问该方法。所以子类也就不存在重写该方法。如果子类中定义了一个与该方法完全相同的方法名，形参列表，**相同的返回值**，那么也不是方法的重写（两同，两小，一大）。只能说是在子类中重新定义了一个方法。因此，即使使用``final``修饰一个``private``访问权限的方法，依然可以在其子类中定义与该方法具有相同的方法名，形参列表，相同的返回值。

    + ``final``修饰的类
        + ``final``修饰的类不可以被继承。

3. ``Java``绑定机制

    1. ``Static Binding``

        + **TODO**
4. 访问权限控制
    1. 类的访问权限
        + public修饰符修饰和无修饰符修饰

    2. 成员访问权限
        + private default(对应无访问修饰符修饰) protected public

    3. 注意：只有先能访问一个类（import导入，或者同一个包下直接访问），然后才能考虑访问这个类的成员变量。即如果不能访问这个类，那么尽管成员变量均为``public``，也不能进行访问成员变量。

    4. 高内聚低耦合
        + 当导入一个包，若与该类同一个包下与导入的包有相同的类名，那么默认会使用导入的包下的类名。如果导入两个包，包下有相同的类名，那么只能通过该类的全名：包名加类名来使用类 **TODO**如果这两个包一个是系统包一个是自定义包呢？？由于双亲委派机制，会报错吗？感觉不会**TODO**

        + 高内聚、低耦合
            + **TODO**

        + ``Java``默认导入``java.lang下的包``
5. 构造器
    1. 在一个构造器中通过``this``调用本类中重载的构造器，必须放在该构造器的第一行。``super``调用父类构造器也必须放在第一行。所以``this``调用和``super``调用不会同时出现。

    2. 不管是否用``super``来显示调用父类构造器，子类构造器总会调用父类构造器，有以下几种情况：
        + 子类构造器执行体的第一行使用``super``显示调用父类构造器，那么系统会根据传入``super``调用里传入的参数来调用父类对应的构造器。

        + 子类构造器执行体的第一行代码使用``this``来显示调用本类中重载的构造器，那么系统会根据``this``调用传入的实参来判断时调用哪个重载的构造器。并且在执行这个重载的构造器的时候会先调用父类的构造器。

        + 子类构造器既没有``super``，也没有``this``，系统会在执行子类构造器之前，隐式调用父类无参构造器（注意：只要是无参构造器即可，当自己显示给某个类定义了一个构造器，那么系统便不会在提供一个无参构造器，所以当没有无参构造器，那么一定要显示调用有参构造器）。

            ```java
                public class Father {
                    private int age = 19;
                    static int id = 11019;
                    //double age = 150.0; //重复定义

                    public static void main(String[] args) {

                    }
                    /*
                    StaticBinding() {
                        //只要是定义了一个构造器，不论是否有参数，那么系统便不会再提供一个无参构造器
                    }
                    */
                    //如果仅仅定义了一个有参构造器，那么子类构造器中一定要显示super调用该构造器。因为此时没有无参构造
                    // 器（只要自己定义了，那么系统便不会显示提供。）
                    Father(int k){
                        System.out.println("父类有参构造器");
                    }
                }

                class Son extends Father {
                    //static int age = 100;

                    private Son() {
                        this(4);
                        System.out.println("nihao1");
                    }

                    private Son(int a) {
                        super(3);
                        System.out.println(a);
                    }
                    /*
                    1.类变量和实例变量一样，可以被继承，而继承的意思就是，在子类中可以直接通过类名.类变量
                    或者实例.实例变量来访问。
                    2.父类成员变量（不区分是否是静态的）如果子类中有一个与之同名的成员变量，那么会发生隐藏的现象
                    即如果要调用父类的成员变量，要通过super或者是类名来访问。注意super不能出现在静态上下文中。
                    3.当父类成员变量是private修饰的时候，那么是不能被继承的。
                    */
                    void thisTest(){
                        System.out.println(this.id);  // 不会报错，但是强烈不建议
                    }

                    public static void main(String[] args) {
                        Son s = new Son();
                        System.out.println(Son.id);  // 会覆盖继承过来的age。注意：要看成员变量的名称
                        //System.out.println(s.age);  // 报错，因为父类中age是private修饰的。
                    }
                }
            ```

            注意：
            1. 静态成员不能访问非静态成员。``this``和``super``属于成员变量中的实例变量，总是指向当前实例。所以``this``和``super``不能出现在静态上下文中。
            2. 当程序创建一个子类对象时，系统不仅仅会为该类中定义的**实例变量**分配内存，也会为它从父类继承得到的所有的实例变量分配内存，即使子类定义了与父类同名的实例变量（注意``private``修饰的方法或者成员变量（包括类变量或者实例变量是不能被继承的）。也就是说，当系统创建了一个``Java``对象时，如果该``Java``类有两个父类（一个直接父类``A``，一个间接父类``B``），假设``A``中定义了2个实例变量，``B``中定义了3个实例变量，当前类定义了2个实例变量，那么这个``Java``对象会保存``2+3+2``个实例变量）
                ![ObjectInMemory](../Image/ExtendsInMemory.png)

6. 多态
    1. 对于``Java``引用类型的变量，总共有两个类型
        + 编译时类型：编译时类型由声明该变量时使用的类型决定
        + 运行时类型：运行时类型由实际赋给该变量的对象决定。

            ```java
                Person person = new Student();  // 编译时类型是Person，运行时类型是Student
            ```

        + 当把子类对象赋值给父类类型引用变量时，被称之为向上转型，这种转型总是可以成功的，所以也可以说子类也是一种特殊的父类。这种转型仅仅表明这个引用变量的编译时类型是父类类型，所以，这个引用变量在调用方法时，仅仅能调用父类中存在的方法，对于父类中不存在的方法，是不能调用的。否则会发生编译错误。

        + 方法重写(override)
            + 方法重写仅仅是针对于实例方法的，对于静态方法，和成员变量（包括实例变量，类变量）不存在方法重写的说法。只能说是继承
            + 重写要遵循**两同，两小，一大**的原则。即两同：方法名相同，形参列表相同。两小：子类方法的返回值类型应该比父类方法返回值类型更小或者相等。子类方法声明抛出的异常要比父类方法声明抛出的异常要更小或者相等。**TODO**一大：子类方法的访问权限要比父类方法的访问权限更大或者相等。
            + 如果父类方法是private，那么该方法对子类是隐藏的。因此子类也无法访问该方法，也就无法重写该方法。如果子类中定义了一个与该方法具有相同的方法名，相同的形参列表，相同的返回值，那么也仅仅是定义了一个新的方法。而不是重写该方法。
            + **TODO**

7. 内部类
    可以将一个类的定义放在另一个类的内部定义，这就是内部类。内部类可以在类中定义，也可以在方法中定义。
    **优点**：《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。
    ![StructureOfInnerClass](../Image/InnerClass.webp)

    1. 非静态内部类
        1. 成员内部类
            + 成员内部类定义在另一个类的内部。没有用``static``关键字修饰。成员内部类可以访问外部类的所有的成员，包括静态成员（访问静态成员，实质上是通过外部类对象``this``来进行访问，而``this``本质上是调用外部类类名来访问静态变量，所以本质上还是**外部类类名**在访**问静态成员**），非静态成员和``private``修饰的成员。
            + **因为成员内部类必须依赖于外部类才能存在。即创建成员内部类实例必须要先创建所在的外部类实例，然后通过该外部类实例来创建成员内部类实例，当外部类实例创建内部类实例时，内部类对象会保存着一个外部类对象的引用。通过该引用，从而能访问外部类的所有的成员（静态，非静态或者``private``）**
                + 编译器自动为成员内部类添加一个**实例变量**（成员内部类不能有``static``修饰的变量或者方法），该变量的类型为外部类类型，这个成员变量实际上指向了外部类对象

                + 编译器自动为内部类的构造方法添加一个参数， 参数的类型是外部类的类型

                + 在调用内部类的构造函数初始化内部类对象时， 会默认传入外部类的引用

                + 访问外部类成员规则如下
                **当在成员内部类的方法内访问某个变量时，会优先在该方法里查找是否存在该名称的局部变量，如果存在，那么就使用该变量，如果不存在，则到该方法所在的内部类中查找是否存在该名称的成员变量，如果存在，那么就使用该成员变量，如果不存在，则到该内部类所在的外部类中查找是否存在改名字的成员变量，如果存在，那么使用该变量，如果不存在，那么直接报错**
                当成员内部类拥有和外部类同名的**成员变量**或者**方法**时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：
                外部类.this.成员变量
                外部类.this.成员方法

            + 成员内部类可以用``private``,``deafult``,``protected``,或者``public``修饰符进行修饰。但是注意一点，因为成员内部类实例对象的创建必须依赖于外部类，所以，必须要先能访问(``import``)外部类，才有可能访问内部类。

            + 成员内部类中不能用静态成员，包括静态**变量**和静态方法。但是可以定义``static final``常量。

        2. 静态内部类
            + 有``static``关键字修饰。静态内部类不依赖于外部类。不持有外部类对象的引用。在没有外部类的对象的前提下，是可以创建静态内部类的对象。所以不能访问外部类的非静态成员，只能访问外部类的静态成员和方法。静态内部类对象的创建可以直接通过 ``new 外部类.内部类``来创建。
            + 静态内部类可以与普通类类似，可以声明静态和非静态变量。

        3. 匿名内部类
            + 匿名内部类必须实现接口或者抽象父类的所有的抽象方法。
            + 匿名内部类会继承一个父类（有且只有一个）或实现一个接口（有且只有一个），实现父类或接口中所有抽象方法，可以重写父类中的普通方法，添加自定义方法。
            + 匿名内部类不能定义**静态成员变量或者方法**。但是自己可以访问静态成员，也可以访问非静态成员。
            + 果我们在匿名内部类中需要访问局部变量，那么这个局部变量必须用``final``修饰符修饰。但``JDK1.8``之后不需要显示的用``final``修饰。

                ```java
                public class InnerTest {

                    int a = 8;
                    static int age = 0;
                    Thread thread = new Thread(new Runnable() {
                        @Override
                        public void run() {
                            System.out.println("在类中定义，而不是方法中");
                        }
                    });

                    public static void main(String[] args) {
                        InnerTest innerTest = new InnerTest();
                        new Thread(new Runnable() {
                            @Override
                            public void run() {
                                System.out.println(age);
                                System.out.println(innerTest.a);  // 注意不能直接访问a，因为a是一个非静态变量，不能出现在静态上下文中
                            }
                            public void add(){
                                System.out.println("新添加的方法");
                            }
                        }).start();
                        innerTest.thread.start();
                    }
                }
                ```
