# 详解锁和``MVCC``

1. 与事务相关的常见``sql``语句
    ``start transaction;``
    ``commit;``
    ``rollback;``
    ``SHOW VARIABLES LIKE 'autocommit';``
    ``savepoint name``(保存点的名称)
    ``rollback to name`` 回滚到该保存点
    在``mysql``中，重复插入的数据如果这两条数据的``row id``不同，那么会被保留 。
    读：``select``
    写:``delete update insert``这三种操作均叫做写

2. 并发事务访问相同记录的情况大致可以分为三种：

    1. 写-写：即并发事务相继对相同的记录进行写访问（其中写访问包括``insert``，``delete``，``update``），会出现脏写的问题，任何一种隔离级别都不允许这种情况发生。多个未提交事务相继对同一条记录进行写操作改动时，会通过锁来实现排队有序的进行修改。从而避免了脏写的问题发生。并且排序修改是``mysql``底层自动帮我们实现。

    2. 读-读：并发事务相继对相同的记录进行读操作，这是完全可以接受的，不会发生数据不安全的问题。

    3. 读-写/写-读：即并发事务的一个事务读一个事务写，可能先读后写也可能先写后读，会出现脏读，不可重复读，幻读的问题。

        + 在``repeatable read``的情况下：通过``MVCC``的``ReadView``，可以解决脏读，不可重复读与幻读的情况发生。但是``SQL``标准规定：``repeatable read``仅仅保证不会出现不可重复读和脏读就可以了，即允许发生幻读的现象。但``MySQL``的``InnoDB``引擎默认的``REPEATABLE READ``级别已经通过``MVCC``自动帮我们解决了幻读的问题（不可重复读和脏读的问题是肯定已经解决了），但是在插入相同的数据的时候，还是会报错的。并且还可以更新这个不存在的数据，即严格来说对于仅仅进行``select``操作，是不会出现幻读的现象发生的，但是对于``update`` 和``delete``，``insert`` 还是能操作这个记录的。

        1. ``MVCC``
            + ``MVCC``，即多版本并发控制。我们知道，并发事务访问相同的记录，可能会出现：读-读，读-写，写-读，写-写几种可能。其中如果所有的事务对某条记录都是进行读操作，那么不会发生数据同步不安全的问题。如果并发事务对某条记录进行了写-写操作，那么可能（注意是可能会发生，如果不是同时对某条记录进行写操作）会发生脏写的问题，在这种情况下，``mysql``会自动对数据进行加锁操作，即第一个写操作没有完成的情况下，第二个写操作会发生阻塞（即在``cmd``窗口中会表现出一直等待的现象）。如果并发事务对某条记录发生了读-写或者写-读的操作，即一个事务正在进行读并且还没有结束，另外的一个事务又开始对该事务进行写操作，那么可能会出现脏读，不可重复读，幻读等问题。在这种情况下，有以下几种情况：

            + ``mysql``中的读操作其实分为两种，一个是一致性读，也叫做快照读，即普通的``select``语句，另一个是锁定读，具有特殊的语法格式。

            + 读-写操作中的读操作如果是普通的查询语句，即``select``，那么不管是``READ COMMITTED``或者``REPEATABLE READ``，在执行``select``时都会生成一个``ReadView``，``ReadView``的存在即解决了脏读的问题。但是这两种隔离级别生成``ReadView``的时机不同，``READ COMMITTED``在每次执行``SELECT``语句都会重新生成一个``ReadView``，从而只能解决脏读的问题，不能解决不可重复读和幻读的问题。但在``REPEATABLE READ``隔离级别下，会在第一次执行``select``查询时生成一个``ReadView``，以后每次查询都会重复使用这个``ReadView``，这样其实不但解决了脏读的问题，还解决了不可重复读和幻读的问题。但是注意：因为这两种隔离级别下都会生成一个``ReadView``，所以都可以解决脏读的问题，只是因为生成``ReadView``的时机不同，导致``REPEATABLE READ``不但能解决脏读的问题，还能解决不可重复读和幻读的问题。

            + ``ReadView``
               + 其实``ReadView``本质上包含4个比较重要的内容：
                   1. 一个是事务``ID``列表，我们知道，对于每条记录，都会有一个隐藏列``trx_id``。不是每一个事务都会分配事务``ID``，只有当该事务包含写操作语句时，系统才会赋予该事务一个事务``ID``，如果仅仅是一个读事务，那么事务``ID``默认为0。这样，在该事务执行的过程中，会将新版本记录的``trx_id``值设置为当前事务``ID``。然后事务``ID``列表中保存着所有的当前活跃的读写事务的事务``ID``
                   2. 最小事务``ID``。表示生成``ReadView``时，当前活动的最小读写事务的事务``ID``，其实也就是上述事务``ID``列表中的最小值
                   3. 下一个事务``ID``，即系统准备分给下一个读写事务的事务``ID``。
                   4. 当前生成该``ReadView``的事务``ID``，如果当前事务还没有执行过写操作，那么当前事务的事务``ID``为0，因为``select``语句是不会生成事务``ID``的。

                   5. 算法流程：通过``roll pointer``，同版本链中选择当前事务可见的版本，显然，事务``ID``列表中的版本肯定是不可见的，因为这些事务还处于活跃中，所以可能会发生脏读脏写的现象。等找到了一个对当前事务可见版本，``select``语句会返回该版本。具体如下：
                      + 如果被访问版本的``trx_id``属性值与``ReadView``中的``creator_trx_id``值相等，那么意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问到
                      + 如果被访问版本的``trx_id``属性值小于``ReadView``中的``min_trx_id``值，那么表明生成该版本的事务在当前事务生成``ReadView``前已经提交，所以该版本可以被当前事务访问。
                      + 如果被访问版本的``trx_id``属性值大于或者等于``ReadView``中的``max_trx_id``，表明生成该版本的事务在当前事务生成``ReadView``才开启，那么该版本不可以当前事务访问。
                      + 如果被访版本的``trx_id``属性值在``ReadView``的``min_trx_id``和``max_trx_id``之间，那么需要判断``trx_id``属性值是不是在当前活跃事务列表中，如果在，说明创建``ReadView``时该版本的事务还是活跃的，所以该版本不可以被访问，如果不在，说明创建``ReadView``时，生成该版本的事务已经被提交，那么该版本可以被访问。
                      + 如果某个版本的数据对当前版本不可见的话，那么顺着版本链找到下一个版本的数据，按照上述的算法流程来继续判断，只要找到一个合适的版本为止。一直倒找版本链的最后一个版本，如果版本链的最后一个版本对当前事务也是不可见的话，那么意味着该记录对当前事务不可见，即查询结果不应该包含该事务

            + ``MVCC``也是默认采用的方式，即我们仅仅用普通的``select``语句进行查询，那么``mysql``底层本质上是采用``MVCC``来解决脏读、不可重复读、幻读现象的。但是我们也可以进行手动采用锁定读``sql``语句，来实现读-写会发生阻塞，从而也能解决脏读、幻读、不可重复读的问题，但是效率比``MVCC``低，因为``MVCC``对于读操作和写操作本质上是不阻塞的，即对一条记录可以同时进行读或者写，但是在某些场景下，我们得读-写要阻塞，不允许读取记录的旧版本。所以需要我们采用加锁的方式。

        2. 通过加锁的方式来解决读写过程中出现的问题
        + ``MVCC``在``REPEATABLE READ``模式下，已经能够解决并发事务访问同一条记录在读-写操作时带来的各种问题，并且读-写操作是不会发生阻塞的，所以为什么还提供了加锁的方式来解决这个问题呢？如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中，你需要先把账户的余额读出来，然后将其加上本次存款的数额，最后再写到数据库中。在将账户余额读取出来后，就不想让别的事务再访问该余额，直到本次存款事务执行完成，其他事务才可以访问账户的余额。这样在读取记录的时候也就需要对其进行加锁操作，这样也就意味着读操作和写操作也像写-写操作那样排队执行，即读-写之间发生了阻塞。
        + 脏读：脏读即意味着别的事务读取了其它未提交事务修改过的数据。``MVCC``通过生成``ReadView``可以解决脏读的问题。那么如果是通过加锁的方式，那么是如何解决？如果另一个事务在写记录的时候就给这条记录加锁，那么当前事务就无法继续读取该记录了，所以也就不会有脏读问题产生。不可重复读是当前事务先读取了一条记录，另外一个事务对该记录做了改动并提交之后，当前事务再次读取到了这条记录，但是内容发生了变化。但是，如果当前事务在读取一条记录时，就给这条记录加锁，那么另外的一个事务就无法修改该记录，所以自然也就不会发生不可重复读的现象了。幻读会采用``gap lock``来解决。

        + 一致性读，也就是快照读，普通的``select``语句。采用``MVCC``来解决并发事务访问带来的一系列脏读，不可重复读，幻读等问题，既不需要我们自己手动指定，``mysql``服务会自动帮我们执行``MVCC``，在每次执行``select``都会生成一个``ReadView``。而加锁的方式来解决这些并发事务带来的问题时，是需要我们自己手动编写锁定读``sql``语句的。

        + 锁定读
        提供两种模式：
            1. ``SELECT ... LOCK IN SHARE MODE``，会获取一条记录的``S``锁
            2. ``SELECT ... FOR UPDATE``，会获取一条记录的``X``锁

    4. 锁的类型：
        + ``S``锁，``X``锁，
            ``IS``锁，``IX``锁：这两个是意向锁。
            **用法**：当我们对使用``InnoDB``存储引擎的表的**某些记录**加``S``锁之前，那么需要在**表级别**增加一个``IS``锁
            用法：当我们对使用``InnoDB``存储引擎的表的**某些记录**加``X``锁之前，那么需要在**表级别**增加一个``IX``锁
            **作用**：``IS``锁和``IX``锁的使命只是为了后续在加**表级别**的``S``锁和``X``锁时判断表中是否有已经被加锁的记录，以避免用遍历的方式来查看表中有没有上锁的记录。因为只要表中的数据只要有一个是加了``X``锁的，那么这个其他事务就不能对这个表加上``X``锁，因为只要是一个事务对一个表增加了那么大粒度的表级锁，说明对整个表的记录都是独占的，而之前的记录已经被别的事务独占了，从而前后发生了矛盾。
        + 表锁类型：
            1. ``S``锁 ``X``锁 基本没用
            2. ``auto——increment``锁

        + 行锁类型：
            一般情况下，新插入一条记录的操作并不加锁，设计``InnoDB``的大叔通过一种称之为隐式锁的东东来保护这条新插入的记录在本事务提交前不被别的事务访问
            在为``AUTO_INCREMENT``列进行自动递增的时候，为了保证插入的数值整个范围内是递增的，会在表级别进行加锁操作。主要有那种加锁操作：

            1. ``AUTO_INC``锁的作用范围只是单个插入语句，即单个``insert``语句。插入语句执行完成后，这个锁就被释放了，而之前的锁只有在事务结束之后会被释放掉。
            2. 轻量级别的锁

    5. 如何解决幻读的出现：

        1. 进行加``Gap Lock``锁
            + ``gap lock``的作用就是锁住一个间隙，防止插入幻影记录。所谓幻读就是当前事务读取了一个范围的记录，然后另外的事务又向该范围插入了新的记录，这样当前事务再次进行该范围的记录时，会读取到新插入的记录，我们把这些新插入的记录称之为幻影记录，通过加``gap lock``，可以防止在某些记录的间隙插入新的记录，从而可以解决幻读现象发生。
            + 说明：``gap``锁仅仅是为了解决幻读的问题产生的。虽然有共享``gap``锁和独占``gap``锁这样的说法，但是它们起到的作用都是相同的。而且如果你对一条记录加了``gap``锁（不论是共享``gap``锁还是独占``gap``锁），并不会限制其他事务对这条记录加正经记录锁或者继续加``gap``锁，再强调一遍，``gap``锁的作用仅仅是为了防止插入幻影记录的而已。

        2. ``MVCC``在隔离级别为``REPEATABLEREAD``隔离级别下，在普通``select``的情况下可以解决幻读的现象

        3. ``next-key``锁的本质就是一个正经记录锁和一个``gap``锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。
