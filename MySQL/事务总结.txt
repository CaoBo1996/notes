事务的定义：需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称之为一个事务（英文名是：transaction）。
事务的特点：

目前支持事物的存储引擎：InonoDB.NDB(不常用).
	1.原子性，现实生活中的转账操作可能对应这=着数据库中的多条操作语句，而转账操作要么成功，要么失败，当对应于数据库，那么完成这个转账操作的那些语句的集合要不然全部成功执行，要不然全部不执行。但是可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的，导致只执行了某些语句，从而不具有原子性。而事务必须要保证原子性操作。
	通过undo log将未提交的事务进行回滚，保证之前的操作不会影响到状态的改变，
	
	发生情况：事务执行过程中可能遇到各种错误，服务器本生的错误，操作系统错误，甚至突然断电。那么会通过undo log来将已经经过修改的部分
	
	***************************
	注意：redo log和undo log的区别
	
	redo log是将一条事务执行的结果数据给保存下来
	而undo log是将事务的操作语句执行之前数据库的执行状态给记录下来
	***************************
	
	
	2.隔离性.对于某个账户转账，若有两个人同时对这个账户转账，那么最终转账的结果应该是这两次转账的和，即这两次转账的操作应该是互不影响的。类比于java中的原子性操作。当对同一内存的变量进行操作，应该是互不影响的。即具有互相隔离的特征。
	通过锁来保证当并发访问同一共享内存的变量时，保证原子性操作。
	
	mysql是一个客户端/服务端软件，对于同一个服务器来说，可能有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事物的一部分，也就是说对于服务器来说，可以同时处理多个事务
	
	
	
	
	
	
	3.持久性：即当某个事务正确完成，那么这个事务对数据的状态改变应该是永久的，应该在磁盘上保存下来，不应该因为其他的原因而被撤销。恢复机制会将redo log中已提交的事务重做，保证事务的持久性；
		1.保证持久性，即要将数据从内存刷新到磁盘。但是如果将修改的页面全部刷新到磁盘有以下两个缺点：
			1.1：刷新一个完整的数据页太浪费		  有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。

			1.2随机IO刷起来比较慢	一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。
			
		本质需求是：我们为了满足持久性，我们要将事务对数据库的修改的部分给记录下来，这样的话，当数据库发生不可预知的错误的时候，比如断电，我们要能将这些被修改的但是还没有刷新到磁盘的数据给回复出来。这样我们只要记录我们修改了那些部分就好了。
		
		解决办法：采用redo log
					优点：1.1redo日志占用的空间非常小
							存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于redo日志的格式我们稍后会详细唠叨，现在只要知道一条redo日志占用的空间不是很大就好了。

						  1.2redo日志是顺序写入磁盘的 		     在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。

			

	
	4.一致性：主要需要程序的编写者来保证。如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的。即比如设计一个成绩数据库，总分100分。那么存入该数据库的成绩是不可能多于100分的。
	由两方面来保证：
		1.mysql自身的语法支持 ，比如not null.比如可以设置一些触发器来检查不合理的输入。
		2.更多的一致性需求需要靠写业务代码的程序员自己保证。
		
	