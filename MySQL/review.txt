事务的定义：需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作称之为一个事务（英文名是：transaction）。
事务的特点：

目前支持事物的存储引擎：InonoDB.NDB(不常用).
	1.原子性，现实生活中的转账操作可能对应这=着数据库中的多条操作语句，而转账操作要么成功，要么失败，当对应于数据库，那么完成这个转账操作的那些语句的集合要不然全部成功执行，要不然全部不执行。但是可能是数据库本身的错误，或者是操作系统错误，甚至是直接断电之类的，导致只执行了某些语句，从而不具有原子性。而事务必须要保证原子性操作。
	通过undo log将未提交的事务进行回滚，保证之前的操作不会影响到状态的改变，
	
	发生情况：事务执行过程中可能遇到各种错误，服务器本生的错误，操作系统错误，甚至突然断电。那么会通过undo log来将已经经过修改的部分
	
	***************************
	注意：redo log和undo log的区别
	
	redo log是将一条事务执行的结果数据给保存下来
	而undo log是将事务的操作语句执行之前数据库的执行状态给记录下来
	***************************
	
	
	2.隔离性.对于某个账户转账，若有两个人同时对这个账户转账，那么最终转账的结果应该是这两次转账的和，即这两次转账的操作应该是互不影响的。类比于java中的原子性操作。当对同一内存的变量进行操作，应该是互不影响的。即具有互相隔离的特征。
	通过锁来保证当并发访问同一共享内存的变量时，保证原子性操作。
	
	mysql是一个客户端/服务端软件，对于同一个服务器来说，可能有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话。每个客户端都可以在自己的会话中向服务器发出请求语句，一个请求语句可能是某个事物的一部分，也就是说对于服务器来说，可以同时处理多个事务。那么就会出现对某个共享变量，可能同时有多个事务对其操作。从而出现某些莫名其妙的情况。
	并发访问可能出现的问题：
		1.脏写：比如一个事务，在执行过程中修改了某一个数据，但是该事务并没有提交，此时，由于服务端可以同时处理多个会话请求，此时另外一个事务也之后修改了这个数据，称这种情况为脏写。
		
		2.脏读：比如一个事务，在执行过程中修改了某一个数据，但是该事务并没有提交，此时，由于服务端可以同时处理多个会话请求，此时另外一个事务读了这个数据，但是之前的事务进行了rollback操作，导致，这个事务相当于读取到了不存在的数据。称这种情况为脏读。
		
		3.不可重复读：对于某个事务，该事务会不断的重复读取(也可能只读取两次)某个数据的值，但是在这事务进行的过程中，有其他事务(可能多个事务)修改了这个数据的值，并且提交了。那么这个事务就很懵逼，为啥我每次读取这个数据都不一样呢？把这种情况叫做不可重复读。
		4.幻读：如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，并且该事务也进行了提交。原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了幻读。
		   幻读强调的是一个事务按照某个相同条件多次读取记录时，后读取时读到了之前没有读到的记录。
           小贴士： 那对于先前已经读到的记录，之后又读取不到这种情况，算啥呢？其实这相当于对每一条记录都发生了不可重复读的现象。幻读只是重点强调了读取到了之前读取没有获取到的记录。 
	
		   由于并发过程可能会出现各种不一样的情况，所以设置了各种隔离级别，对每一种隔离级别，解决了不同的问题。
		   隔离级别的种类：
		   SQL规定：
		   read uncommitted：可能发生脏读，不可重复读，幻读
		   read committed：不可以发生脏读，但是可能会发生重复度和幻读
		   repeatable read：可能会发生幻读的现象，但是不会发生不可重复读和脏读
		   serializable：各种问题都还不会发生。
		   
		   注：对于上述的隔离级别，均不会允许发生脏写。
		   不同的隔离性造成的性能差异很大。我们上边所说的舍弃一部分隔离性来换取一部分性能在这里就体现在：设立一些隔离级别，隔离级别越低，越严重的问题就越可能发生
		   
		   注：mysql的默认隔离级别是repeatale read,并且与sql标准不同的是，mysql在repeatable read的情况下是可以通过一些设置来防止幻读的现象发生。
	
		   MVCC原理：
				trx_id:隐藏列，事务ID
				roll_pointer:指向前一个版本的隐藏列
				
	
	3.持久性：即当某个事务正确完成，那么这个事务对数据的状态改变应该是永久的，应该在磁盘上保存下来，不应该因为其他的原因而被撤销。恢复机制会将redo log中已提交的事务重做，保证事务的持久性；
		1.保证持久性，即要将数据从内存刷新到磁盘。但是如果将修改的页面全部刷新到磁盘有以下两个缺点：
			1.1：刷新一个完整的数据页太浪费		  有时候我们仅仅修改了某个页面中的一个字节，但是我们知道在InnoDB中是以页为单位来进行磁盘IO的，也就是说我们在该事务提交时不得不将一个完整的页面从内存中刷新到磁盘，我们又知道一个页面默认是16KB大小，只修改一个字节就要刷新16KB的数据到磁盘上显然是太浪费了。

			1.2随机IO刷起来比较慢	一个事务可能包含很多语句，即使是一条语句也可能修改许多页面，倒霉催的是该事务修改的这些页面可能并不相邻，这就意味着在将某个事务修改的Buffer Pool中的页面刷新到磁盘时，需要进行很多的随机IO，随机IO比顺序IO要慢，尤其对于传统的机械硬盘来说。
			
		本质需求是：我们为了满足持久性，我们要将事务对数据库的修改的部分给记录下来，这样的话，当数据库发生不可预知的错误的时候，比如断电，我们要能将这些被修改的但是还没有刷新到磁盘的数据给回复出来。这样我们只要记录我们修改了那些部分就好了。
		
		解决办法：采用redo log
					优点：1.1redo日志占用的空间非常小
							存储表空间ID、页号、偏移量以及需要更新的值所需的存储空间是很小的，关于redo日志的格式我们稍后会详细唠叨，现在只要知道一条redo日志占用的空间不是很大就好了。

						  1.2redo日志是顺序写入磁盘的 		     在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO。

			

	
	4.一致性：主要需要程序的编写者来保证。如果数据库中的数据全部符合现实世界中的约束（all defined rules），我们说这些数据就是一致的。即比如设计一个成绩数据库，总分100分。那么存入该数据库的成绩是不可能多于100分的。
	由两方面来保证：
		1.mysql自身的语法支持 ，比如not null.比如可以设置一些触发器来检查不合理的输入。
		2.更多的一致性需求需要靠写业务代码的程序员自己保证。
		
	